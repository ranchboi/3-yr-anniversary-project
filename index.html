<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Our Adventure</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚ù§Ô∏è</text></svg>">
  <style>
    :root { color-scheme: dark; }
    body{
      margin:0; height:100vh; display:grid; place-items:center;
      background: radial-gradient(1200px 700px at 50% 35%, #1f2440 0%, #0b0d12 60%, #05060a 100%);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overflow:hidden;
    }
    .wrap{ width:min(980px, 96vw); }
    .hud{
      display:flex; justify-content:space-between; align-items:center;
      margin:10px 6px 12px; color:#d7dbe7; opacity:.95; gap:10px; flex-wrap:wrap;
    }
    .badge{
      font-size:12px; letter-spacing:.2px;
      padding:6px 10px; border:1px solid rgba(255,255,255,.12);
      border-radius:999px; background:rgba(255,255,255,.04);
      backdrop-filter: blur(8px);
      display:flex; align-items:center; gap:8px;
    }
    canvas{
      width:100%; aspect-ratio:16/9; display:block;
      border-radius:18px;
      border:1px solid rgba(255,255,255,.12);
      box-shadow: 0 18px 70px rgba(0,0,0,.55);
      background: rgba(255,255,255,.02);
      image-rendering: crisp-edges;
      image-rendering: -webkit-optimize-contrast;
    }
    .tip{
      margin:10px 6px 0; color:rgba(215,219,231,.82); font-size:13px;
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
    }
    kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12px; border:1px solid rgba(255,255,255,.18);
      border-bottom-color: rgba(255,255,255,.28);
      padding:3px 6px; border-radius:8px; background:rgba(255,255,255,.06);
    }

    /* Modal */
    .modal{
      position:fixed; inset:0; display:none; place-items:center;
      background: rgba(0,0,0,.55);
      padding: 18px;
    }
    .modal.show{ display:grid; }
    .panel{
      width: min(980px, 96vw);
      max-height: min(84vh, 720px);
      overflow:auto;
      border-radius: 18px;
      border: 2px solid rgba(255,255,255,.16);
      background: rgba(10,12,18,.86);
      box-shadow: 0 30px 90px rgba(0,0,0,.65);
      padding: 14px 14px 18px;
    }
    .panelHeader{
      display:flex; justify-content:space-between; align-items:flex-start; gap: 12px;
      padding: 6px 6px 10px;
    }
    .panelTitle{
      font-weight: 800; font-size: 18px; color: rgba(255,255,255,.92);
    }
    .panelSub{
      font-size: 12px; color: rgba(215,219,231,.72); margin-top: 4px;
    }
    .btn{
      appearance:none; border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.9);
      padding: 8px 10px; border-radius: 12px;
      font-weight: 650; cursor:pointer;
    }
    .btn:hover{ background: rgba(255,255,255,.09); }
    .grid{
      display:grid;
      grid-template-columns: repeat(auto-fill, minmax(190px, 1fr));
      gap: 12px;
      padding: 6px;
    }
    .card{
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
      overflow:hidden;
    }
    .thumb{
      width:100%; aspect-ratio: 4/3; object-fit: cover; display:block;
      background: rgba(255,255,255,.03);
    }
    .cap{
      padding: 10px 10px 12px;
      color: rgba(215,219,231,.92);
      font-size: 13px;
      line-height: 1.25rem;
    }
    .cap .date{
      display:block;
      margin-bottom: 6px;
      color: rgba(215,219,231,.65);
      font-size: 12px;
    }

    /* Pok√©mon-ish dialog */
    .dialog{
      position:absolute;
      left: 50%; transform: translateX(-50%);
      bottom: 22px;
      width: min(920px, calc(100% - 60px));
      padding: 12px 14px;
      border-radius: 14px;
      border: 2px solid rgba(255,255,255,.18);
      background: rgba(10,12,18,.78);
      box-shadow: 0 20px 70px rgba(0,0,0,.55);
      display:none;
    }
    .dialog.show{ display:flex; flex-direction: column; }
    .dialogHeader{
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }
    .dialogTitle{
      font-weight: 800;
      font-size: 14px;
      color: rgba(255,255,255,.92);
    }
    .dialogHint{
      font-size: 11px;
      color: rgba(255,255,255,.5);
      padding: 4px 8px;
      background: rgba(255,255,255,.08);
      border-radius: 6px;
    }
    .dialogText{
      color: rgba(215,219,231,.92);
      font-size: 14px;
      line-height: 1.35rem;
      white-space: pre-wrap;
    }

    /* Pokemon Battle UI */
    .battle-screen {
      position: fixed;
      inset: 0;
      display: none;
      background: linear-gradient(180deg, #87ceeb 0%, #98fb98 50%, #228b22 100%);
      z-index: 1000;
      font-family: 'Courier New', monospace;
    }
    .battle-screen.show { display: flex; flex-direction: column; }
    
    .battle-arena {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      padding: 20px;
      position: relative;
    }
    
    .enemy-side {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }
    
    .player-side {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
    }
    
    .pokemon-sprite {
      width: 120px;
      height: 120px;
      object-fit: contain;
      filter: drop-shadow(4px 4px 8px rgba(0,0,0,0.3));
      animation: bounce 1s ease-in-out infinite;
      border-radius: 12px;
    }
    
    .pokemon-sprite.player {
      width: 150px;
      height: 150px;
    }
    
    .pokemon-sprite.enemy-emoji {
      font-size: 100px;
      text-shadow: 4px 4px 8px rgba(0,0,0,0.3);
      width: auto;
      height: auto;
    }
    
    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
    
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }
    
    @keyframes flash {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
    
    .pokemon-sprite.hit {
      animation: shake 0.3s ease-in-out, flash 0.3s ease-in-out;
    }
    
    .hp-bar-container {
      background: #2a2a2a;
      border: 3px solid #1a1a1a;
      border-radius: 8px;
      padding: 10px 15px;
      min-width: 220px;
      box-shadow: 4px 4px 0 rgba(0,0,0,0.3);
    }
    
    .pokemon-name {
      font-weight: bold;
      font-size: 18px;
      color: #1a1a1a;
      margin-bottom: 5px;
      background: rgba(255, 255, 255, 0.9);
      padding: 4px 10px;
      border-radius: 6px;
      display: inline-block;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .pokemon-level {
      font-size: 14px;
      color: #333;
      margin-left: 10px;
    }
    
    .hp-bar-outer {
      background: #333;
      border-radius: 10px;
      height: 12px;
      overflow: hidden;
      border: 2px solid #1a1a1a;
    }
    
    .hp-bar-inner {
      height: 100%;
      background: linear-gradient(180deg, #4ade80 0%, #22c55e 50%, #16a34a 100%);
      transition: width 0.5s ease-out;
      border-radius: 10px;
    }
    
    .hp-bar-inner.low { background: linear-gradient(180deg, #fbbf24 0%, #f59e0b 50%, #d97706 100%); }
    .hp-bar-inner.critical { background: linear-gradient(180deg, #f87171 0%, #ef4444 50%, #dc2626 100%); }
    
    .hp-text {
      font-size: 12px;
      color: #666;
      text-align: right;
      margin-top: 3px;
    }
    
    .battle-ui {
      background: linear-gradient(180deg, #3a3a3a 0%, #2a2a2a 100%);
      border-top: 4px solid #1a1a1a;
      padding: 15px;
      display: flex;
      gap: 15px;
    }
    
    .battle-text-box {
      flex: 1;
      background: #f5f5f5;
      border: 3px solid #1a1a1a;
      border-radius: 8px;
      padding: 15px;
      font-size: 18px;
      color: #1a1a1a;
      min-height: 80px;
      display: flex;
      align-items: center;
      box-shadow: inset 2px 2px 0 rgba(0,0,0,0.1);
    }
    
    .battle-menu {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      min-width: 280px;
    }
    
    .battle-btn {
      background: linear-gradient(180deg, #f5f5f5 0%, #e5e5e5 100%);
      border: 3px solid #1a1a1a;
      border-radius: 8px;
      padding: 12px 20px;
      font-family: 'Courier New', monospace;
      font-size: 16px;
      font-weight: bold;
      color: #1a1a1a;
      cursor: pointer;
      transition: all 0.1s;
      box-shadow: 3px 3px 0 rgba(0,0,0,0.3);
    }
    
    .battle-btn:hover {
      background: linear-gradient(180deg, #fff 0%, #f5f5f5 100%);
      transform: translate(-1px, -1px);
      box-shadow: 4px 4px 0 rgba(0,0,0,0.3);
    }
    
    .battle-btn:active {
      transform: translate(2px, 2px);
      box-shadow: 1px 1px 0 rgba(0,0,0,0.3);
    }
    
    .battle-btn.fight { background: linear-gradient(180deg, #fca5a5 0%, #f87171 100%); }
    .battle-btn.bag { background: linear-gradient(180deg, #fcd34d 0%, #fbbf24 100%); }
    .battle-btn.defend { background: linear-gradient(180deg, #93c5fd 0%, #60a5fa 100%); }
    .battle-btn.run { background: linear-gradient(180deg, #a5f3fc 0%, #67e8f9 100%); }
    
    .sub-menu {
      display: none;
    }
    .sub-menu.show {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      min-width: 280px;
    }
    
    .battle-btn.back {
      grid-column: span 2;
      background: linear-gradient(180deg, #d4d4d4 0%, #a3a3a3 100%);
    }
    
    /* Celebration Screen */
    .celebration-screen {
      position: fixed;
      inset: 0;
      display: none;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      z-index: 2000;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      font-family: 'Georgia', serif;
    }
    .celebration-screen.show { display: flex; }
    
    .hearts-container {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
    }
    
    .floating-heart {
      position: absolute;
      font-size: 30px;
      animation: floatUp 4s ease-out forwards;
      opacity: 0;
    }
    
    @keyframes floatUp {
      0% { transform: translateY(100vh) rotate(0deg); opacity: 1; }
      100% { transform: translateY(-100px) rotate(360deg); opacity: 0; }
    }
    
    .slideshow-container {
      position: relative;
      width: 350px;
      height: 280px;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5), 0 0 60px rgba(255,105,180,0.3);
      border: 4px solid rgba(255,255,255,0.2);
      margin-bottom: 30px;
    }
    
    .slideshow-img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: opacity 0.5s ease;
    }
    
    /* Floating background images */
    .floating-image {
      position: absolute;
      width: 80px;
      height: 60px;
      object-fit: cover;
      border-radius: 8px;
      opacity: 0;
      pointer-events: none;
      animation: floatImage 8s ease-in-out forwards;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    
    @keyframes floatImage {
      0% { 
        opacity: 0; 
        transform: translateY(50px) rotate(-5deg) scale(0.8); 
      }
      15% { 
        opacity: 0.4; 
      }
      50% { 
        opacity: 0.5; 
        transform: translateY(-20px) rotate(5deg) scale(1); 
      }
      85% { 
        opacity: 0.3; 
      }
      100% { 
        opacity: 0; 
        transform: translateY(-80px) rotate(-3deg) scale(0.9); 
      }
    }
    
    .celebration-message {
      max-width: 600px;
      text-align: center;
      color: #fff;
      padding: 30px;
      background: rgba(255,255,255,0.1);
      border-radius: 20px;
      backdrop-filter: blur(10px);
      margin: 20px;
      line-height: 1.8;
      font-size: 18px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }
    
    .celebration-message p {
      margin: 0 0 20px 0;
    }
    
    .celebration-message .question {
      font-size: 24px;
      font-weight: bold;
      color: #ff69b4;
      margin-top: 25px;
      text-shadow: 0 0 20px rgba(255,105,180,0.5);
    }
    
    .celebration-buttons {
      display: flex;
      gap: 30px;
      margin-top: 25px;
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .celebration-btn {
      padding: 15px 40px;
      font-size: 20px;
      font-weight: bold;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: 'Georgia', serif;
    }
    
    .celebration-btn.yes {
      background: linear-gradient(135deg, #00c853 0%, #00e676 100%);
      color: white;
      box-shadow: 0 6px 20px rgba(0,200,83,0.4);
    }
    
    .celebration-btn.yes:hover {
      transform: scale(1.1);
      box-shadow: 0 8px 30px rgba(0,200,83,0.6);
    }
    
    .celebration-btn.no {
      background: linear-gradient(135deg, #d32f2f 0%, #f44336 100%);
      color: white;
      box-shadow: 0 6px 20px rgba(211,47,47,0.4);
    }
    
    .celebration-btn.no:hover {
      transform: scale(0.95);
    }
    
    .confetti {
      position: absolute;
      width: 10px;
      height: 10px;
      animation: confettiFall 3s ease-out forwards;
    }
    
    @keyframes confettiFall {
      0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }
    
    .final-celebration {
      position: fixed;
      inset: 0;
      display: none;
      background: linear-gradient(135deg, #ff69b4 0%, #ff1493 50%, #ff69b4 100%);
      z-index: 3000;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      animation: rainbowBg 3s ease infinite;
    }
    .final-celebration.show { display: flex; }
    
    /* Lightbox for viewing full images */
    .lightbox {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.95);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 5000;
      cursor: pointer;
    }
    .lightbox.show { display: flex; }
    
    .lightbox img {
      max-width: 90vw;
      max-height: 85vh;
      object-fit: contain;
      border-radius: 8px;
      box-shadow: 0 10px 50px rgba(0,0,0,0.5);
    }
    
    .lightbox-caption {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 12px 24px;
      border-radius: 8px;
      font-size: 16px;
      max-width: 80%;
      text-align: center;
    }
    
    .lightbox-close {
      position: absolute;
      top: 20px;
      right: 30px;
      font-size: 40px;
      color: white;
      cursor: pointer;
      opacity: 0.8;
      transition: opacity 0.2s;
    }
    .lightbox-close:hover { opacity: 1; }
    
    .lightbox-hint {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.6);
      font-size: 14px;
    }
    
    .thumb {
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }
    .thumb:hover {
      transform: scale(1.02);
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }
    
    @keyframes rainbowBg {
      0%, 100% { background: linear-gradient(135deg, #ff69b4 0%, #ff1493 100%); }
      50% { background: linear-gradient(135deg, #ff1493 0%, #ff69b4 100%); }
    }
    
    .final-celebration h1 {
      font-size: 60px;
      color: white;
      text-shadow: 0 0 30px rgba(255,255,255,0.8);
      animation: pulse 1s ease infinite;
      margin: 0;
    }
    
    .final-celebration p {
      font-size: 30px;
      color: white;
      margin-top: 20px;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }
    
    /* Mobile Controls */
    .mobile-controls {
      display: none;
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      gap: 15px;
    }
    
    .mobile-btn {
      background: linear-gradient(135deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0.05) 100%);
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 50px;
      padding: 15px 30px;
      color: white;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
      transition: all 0.2s;
    }
    
    .mobile-btn:active {
      transform: scale(0.95);
      background: rgba(255,255,255,0.25);
    }
    
    .mobile-btn.interact {
      background: linear-gradient(135deg, #4CAF50 0%, #2E7D32 100%);
      border-color: #81C784;
      display: none;
    }
    
    .mobile-btn.interact.show {
      display: block;
    }
    
    /* Mobile Responsive Styles */
    @media (max-width: 768px) {
      .wrap { width: 100vw; }
      
      canvas {
        width: 100%;
        border-radius: 0;
        aspect-ratio: 16/10;
      }
      
      .hud {
        margin: 5px;
        font-size: 11px;
      }
      
      .badge {
        padding: 4px 8px;
        font-size: 10px;
      }
      
      .btn {
        padding: 6px 8px;
        font-size: 11px;
      }
      
      .tip {
        display: none;
      }
      
      .tip-mobile {
        display: block;
        margin: 8px;
        color: rgba(215,219,231,.7);
        font-size: 12px;
        text-align: center;
      }
      
      .mobile-controls {
        display: flex;
      }
      
      .dialog {
        bottom: 100px;
        width: calc(100% - 30px);
        padding: 10px 12px;
      }
      
      .dialogText {
        font-size: 13px;
      }
      
      .panel {
        width: 95vw;
        max-height: 80vh;
        padding: 10px;
      }
      
      .grid {
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 8px;
      }
      
      /* Battle screen mobile */
      .battle-arena {
        padding: 10px;
      }
      
      .pokemon-sprite {
        width: 80px;
        height: 80px;
      }
      
      .pokemon-sprite.player {
        width: 100px;
        height: 100px;
      }
      
      .hp-bar-container {
        min-width: 150px;
        padding: 6px 10px;
      }
      
      .pokemon-name {
        font-size: 14px;
      }
      
      .battle-ui {
        flex-direction: column;
        padding: 10px;
        gap: 10px;
      }
      
      .battle-text-box {
        font-size: 14px;
        min-height: 60px;
        padding: 10px;
      }
      
      .battle-menu, .sub-menu.show {
        min-width: unset;
        width: 100%;
      }
      
      .battle-btn {
        padding: 10px 15px;
        font-size: 14px;
      }
      
      /* Celebration mobile */
      .slideshow-container {
        width: 280px;
        height: 220px;
      }
      
      .celebration-message {
        padding: 20px;
        margin: 10px;
        font-size: 14px;
        line-height: 1.6;
      }
      
      .celebration-message .question {
        font-size: 18px;
      }
      
      .celebration-btn {
        padding: 12px 30px;
        font-size: 16px;
      }
      
      .final-celebration h1 {
        font-size: 36px;
      }
      
      .final-celebration p {
        font-size: 20px;
      }
      
      /* Lightbox mobile */
      .lightbox img {
        max-width: 95vw;
        max-height: 80vh;
      }
      
      .lightbox-caption {
        font-size: 14px;
        padding: 10px 15px;
      }
    }
    
    @media (max-width: 480px) {
      .hud {
        flex-direction: column;
        align-items: stretch;
        gap: 5px;
      }
      
      .badge {
        justify-content: center;
      }
      
      .pokemon-sprite {
        width: 60px;
        height: 60px;
      }
      
      .pokemon-sprite.player {
        width: 80px;
        height: 80px;
      }
      
      .hp-bar-container {
        min-width: 120px;
      }
      
      .slideshow-container {
        width: 240px;
        height: 180px;
      }
      
      .celebration-message {
        font-size: 13px;
      }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="badge" id="leftBadge">Loading‚Ä¶</div>
      <div class="badge">
        <button class="btn" id="muteBtn">üîä Music</button>
        <button class="btn" id="openYearsBtn">üì∏ Open Years</button>
      </div>
    </div>

    <div style="position:relative;">
      <canvas id="game" width="1280" height="720" tabindex="0"></canvas>
      <div class="dialog" id="dialog">
        <div class="dialogHeader">
          <div class="dialogTitle" id="dialogTitle">Sign</div>
          <div class="dialogHint">Click away to close</div>
        </div>
        <div class="dialogText" id="dialogText"></div>
      </div>
    </div>

    <div class="tip">
      Move: Click/Tap anywhere on the map
      ‚Ä¢ Interact: <kbd>E</kbd>
      ‚Ä¢ Close: <kbd>Esc</kbd>
    </div>
    <div class="tip-mobile" style="display:none;">
      Tap anywhere to move ‚Ä¢ Use buttons below to interact
    </div>
  </div>
  
  <!-- Mobile Controls -->
  <div class="mobile-controls" id="mobileControls">
    <button class="mobile-btn interact" id="mobileInteractBtn">‚ú® Interact</button>
  </div>

  <!-- Pokemon Battle Screen -->
  <div class="battle-screen" id="battleScreen">
    <div class="battle-arena">
      <div class="enemy-side">
        <div class="hp-bar-container">
          <div class="pokemon-name">Wild <span id="enemyName">Alex</span> <span class="pokemon-level">Lv.5</span></div>
          <div class="hp-bar-outer">
            <div class="hp-bar-inner" id="enemyHpBar" style="width: 100%"></div>
          </div>
          <div class="hp-text"><span id="enemyHpText">50</span> / <span id="enemyMaxHpText">50</span></div>
        </div>
        <img class="pokemon-sprite" id="enemySprite" src="assets/images/animal images/pluto image.jpeg" alt="Enemy">
      </div>
      
      <div class="player-side">
        <img class="pokemon-sprite player" id="playerSprite" src="assets/images/animal images/chloe image.jpeg" alt="Chloe">
        <div class="hp-bar-container">
          <div class="pokemon-name">Chloe <span class="pokemon-level">Lv.10</span></div>
          <div class="hp-bar-outer">
            <div class="hp-bar-inner" id="playerHpBar" style="width: 100%"></div>
          </div>
          <div class="hp-text"><span id="playerHpText">80</span> / <span id="playerMaxHpText">80</span></div>
        </div>
      </div>
    </div>
    
    <div class="battle-ui">
      <div class="battle-text-box" id="battleText">A wild Alex appeared!</div>
      
      <div class="battle-menu" id="mainMenu">
        <button class="battle-btn fight" onclick="showFightMenu()">‚öîÔ∏è FIGHT</button>
        <button class="battle-btn bag" onclick="showBagMenu()">üéí BAG</button>
        <button class="battle-btn defend" onclick="useDefend()">üõ°Ô∏è DEFEND</button>
        <button class="battle-btn run" onclick="tryRun()">üèÉ RUN</button>
      </div>
      
      <div class="sub-menu" id="fightMenu">
        <button class="battle-btn fight" onclick="useMove('Bark Attack', 15)">üîä Bark Attack</button>
        <button class="battle-btn fight" onclick="useMove('Tail Whip', 10)">üí´ Tail Whip</button>
        <button class="battle-btn fight" onclick="useMove('Pounce', 20)">üêæ Pounce</button>
        <button class="battle-btn fight" onclick="useMove('Jump Run', 25)">üèÉ Jump Run</button>
        <button class="battle-btn back" onclick="showMainMenu()">‚Üê Back</button>
      </div>
      
      <div class="sub-menu" id="bagMenu">
        <button class="battle-btn bag" id="itemTreats" onclick="useItem('Treats', 15)">üçñ Treats (+15 HP) x2</button>
        <button class="battle-btn bag" id="itemDogFood" onclick="useItem('Dog Food', 25)">ü¶¥ Dog Food (+25 HP) x2</button>
        <button class="battle-btn bag" id="itemWaterBowl" onclick="useItem('Water Bowl', 50)">üíß Water Bowl (+50 HP) x2</button>
        <button class="battle-btn bag" id="itemSuperSnack" onclick="useItem('Super Snack', 75)">ü•© Super Snack (+75 HP) x1</button>
        <button class="battle-btn back" onclick="showMainMenu()">‚Üê Back</button>
      </div>
    </div>
  </div>

  <!-- Celebration Screen -->
  <div class="celebration-screen" id="celebrationScreen">
    <div class="hearts-container" id="heartsContainer"></div>
    <div class="slideshow-container">
      <img class="slideshow-img" id="slideshowImg" src="" alt="Memory">
    </div>
    <div class="celebration-message">
      <p>Dear Izzy,</p>
      <p>You have been the love of my life since the day I have met you and I love nothing more than loving you every day of my life.</p>
      <p>You have made the past 3 years the best and I love everything that we have done including going on sushi dates, out with our friends or playing games.</p>
      <p>I loved spending every minute with you and I love you endlessly.</p>
      <p class="question">Now that you are on the final step of this game I worked so hard on, Would you like to step into year 4 with me?</p>
      <div class="celebration-buttons">
        <button class="celebration-btn yes" id="yesBtn" onclick="handleYes()">üíö YES! üíö</button>
        <button class="celebration-btn no" id="noBtn" onclick="handleNo()">üò¢ No :(</button>
      </div>
    </div>
  </div>
  
  <!-- Final Celebration -->
  <div class="final-celebration" id="finalCelebration">
    <h1>üíï SHE SAID YES! üíï</h1>
    <p>Here's to Year 4 and forever! üéâ</p>
    <button class="celebration-btn yes" style="margin-top: 40px;" onclick="playAgain()">üîÑ Play Again</button>
  </div>

  <!-- Lightbox for full image view -->
  <div class="lightbox" id="lightbox" onclick="closeLightbox()">
    <div class="lightbox-hint">Click anywhere to close</div>
    <span class="lightbox-close" onclick="closeLightbox()">&times;</span>
    <img id="lightboxImg" src="" alt="Full image">
    <div class="lightbox-caption" id="lightboxCaption"></div>
  </div>

  <div class="modal" id="modal">
    <div class="panel">
      <div class="panelHeader">
        <div>
          <div class="panelTitle" id="modalTitle">Years</div>
          <div class="panelSub" id="modalSub">Pick a year</div>
        </div>
        <div style="display:flex; gap:8px;">
          <button class="btn" id="closeModalBtn">Close</button>
        </div>
      </div>
      <div id="modalBody"></div>
    </div>
  </div>

<script>
/* =========================
   LOAD MANIFEST
   ========================= */
// If you kept the name "mainfest.json", change this line to:
// const manifestUrl = "mainfest.json";
const manifestUrl = "manifest.json";

let MANIFEST = null;

async function loadManifest(){
  const res = await fetch(manifestUrl, { cache: "no-store" });
  if (!res.ok) throw new Error("Could not load manifest file.");
  MANIFEST = await res.json();

  MANIFEST.years = (MANIFEST.years || []).map(y => ({
    ...y,
    entries: (y.entries || []).slice().sort((a,b) => {
      const da = a.date ? Date.parse(a.date) : 0;
      const db = b.date ? Date.parse(b.date) : 0;
      if (da && db) return da - db;
      return (a.src || "").localeCompare(b.src || "");
    })
  })).sort((a,b) => a.year - b.year);

  updateHud();
  buildWorldFromManifest();
}

/* =========================
   BASIC UI
   ========================= */
const leftBadge = document.getElementById("leftBadge");
const modal = document.getElementById("modal");
const modalTitle = document.getElementById("modalTitle");
const modalSub = document.getElementById("modalSub");
const modalBody = document.getElementById("modalBody");

document.getElementById("closeModalBtn").onclick = () => hideModal();
document.getElementById("openYearsBtn").onclick = () => showYearPicker();

// Close modal when clicking outside the panel (but not when editing)
let isEditingCaption = false;
modal.addEventListener("click", (e) => {
  if (e.target === modal && !isEditingCaption) {
    hideModal();
  }
});

function updateHud(){
  leftBadge.textContent = `üéí ${MANIFEST.title || "Our Adventure"} ‚Ä¢ ${MANIFEST.playerName || "Player"} √ó ${MANIFEST.partnerName || "Partner"}`;
}

/* =========================
   MUSIC (user-provided)
   ========================= */
let audio = null;
let battleAudio = null;
let victoryAudio = null;
let muted = false;
const muteBtn = document.getElementById("muteBtn");

// Music paths
const BATTLE_MUSIC_PATH = "assets/music/Pok√©mon Omega Ruby & Alpha Sapphire - Zinnia Battle Music (HQ).mp3";
const VICTORY_MUSIC_PATH = "assets/music/Pok√©mon Red & Blue Music_ Gym Leader Victory Theme.mp3";

function setupMusic(){
  if (!MANIFEST.bgm) {
    muteBtn.disabled = true;
    muteBtn.textContent = "üîá No Music";
    return;
  }
  audio = new Audio(MANIFEST.bgm);
  audio.loop = true;
  audio.volume = 0.55;

  let musicStarted = false;
  const start = async () => {
    if (musicStarted) return;
    musicStarted = true;
    try { await audio.play(); } catch {}
    window.removeEventListener("pointerdown", start);
    window.removeEventListener("keydown", startMusic);
  };
  const startMusic = (e) => {
    const k = e.key.length===1 ? e.key.toLowerCase() : e.key;
    // Don't interfere with movement keys
    if (!["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","w","a","s","d"].includes(k)) {
      start();
    }
  };
  window.addEventListener("pointerdown", start, { once:false });
  window.addEventListener("keydown", startMusic, { once:false });

  muteBtn.onclick = () => {
    muted = !muted;
    audio.muted = muted;
    if (battleAudio) battleAudio.muted = muted;
    if (victoryAudio) victoryAudio.muted = muted;
    muteBtn.textContent = muted ? "üîá Music" : "üîä Music";
  };
}

function startBattleMusic() {
  // Pause overworld music
  if (audio) {
    audio.pause();
  }
  
  // Start battle music
  if (!battleAudio) {
    battleAudio = new Audio(BATTLE_MUSIC_PATH);
    battleAudio.loop = true;
    battleAudio.volume = 0.6;
  }
  battleAudio.currentTime = 0;
  battleAudio.muted = muted;
  battleAudio.play().catch(() => {}); // Ignore autoplay errors
}

function stopBattleMusic() {
  // Stop battle music
  if (battleAudio) {
    battleAudio.pause();
    battleAudio.currentTime = 0;
  }
  
  // Resume overworld music
  if (audio && !muted) {
    audio.play().catch(() => {});
  }
}

function startVictoryMusic() {
  // Pause overworld and battle music
  if (audio) audio.pause();
  if (battleAudio) battleAudio.pause();
  
  // Start victory music
  if (!victoryAudio) {
    victoryAudio = new Audio(VICTORY_MUSIC_PATH);
    victoryAudio.loop = true;
    victoryAudio.volume = 0.7;
  }
  victoryAudio.currentTime = 0;
  victoryAudio.muted = muted;
  victoryAudio.play().catch(() => {});
}

function stopVictoryMusic() {
  if (victoryAudio) {
    victoryAudio.pause();
    victoryAudio.currentTime = 0;
  }
}

/* =========================
   OVERWORLD (tile map)
   ========================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const W = canvas.width, H = canvas.height;

// Improve canvas rendering quality - crisp pixels
ctx.imageSmoothingEnabled = false;

// Ensure canvas can receive focus for keyboard events
canvas.focus();
canvas.addEventListener("click", () => canvas.focus());

const TILE = 32;
const MAP_W = 100;
const MAP_H = 60;
const worldPx = { w: MAP_W*TILE, h: MAP_H*TILE };
const cam = { x: 0, y: 0 };

const player = {
  x: 8*TILE + TILE/2,
  y: 30*TILE + TILE/2,
  speed: 220,
  targetX: null,
  targetY: null,
  isMoving: false,
  walkFrame: 0,
  lastWalkTime: 0,
  facingRight: true, // Track which direction player is facing
};

const T_GRASS=0, T_PATH=1, T_WATER=2, T_TREE=3, T_SIGN=4, T_ROCK=5, T_BUSH=6, T_BUSH_RABBIT=7;

let map = [];
let solid = new Set();
let signs = [];
let welcomeSign = { x: 0, y: 0 };
let goal = { x: 0, y: 0 };
let pokemaster = { x: 0, y: 0 };
let pokemaster2 = { x: 0, y: 0 };
let rockEmojis = []; // Decorative rock emojis

function idx(x,y){ return y*MAP_W + x; }
function inBounds(x,y){ return x>=0 && y>=0 && x<MAP_W && y<MAP_H; }

function buildBaseMap(){
  map = new Array(MAP_W*MAP_H).fill(T_GRASS);
  solid.clear();

  // Border trees
  for (let x=0;x<MAP_W;x++){
    map[idx(x,0)] = T_TREE; map[idx(x,MAP_H-1)] = T_TREE;
  }
  for (let y=0;y<MAP_H;y++){
    map[idx(0,y)] = T_TREE; map[idx(MAP_W-1,y)] = T_TREE;
  }

  // Main horizontal paths (multiple routes)
  for (let x=3;x<MAP_W-3;x++) {
    map[idx(x,15)] = T_PATH;  // Northern route
    map[idx(x,30)] = T_PATH;  // Central route (starting area)
    map[idx(x,45)] = T_PATH;  // Southern route
  }

  // Main vertical paths
  for (let y=3;y<MAP_H-3;y++) {
    map[idx(20,y)] = T_PATH;  // Western path
    map[idx(50,y)] = T_PATH;  // Central path
    map[idx(80,y)] = T_PATH;  // Eastern path
  }

  // Cross paths connecting main routes
  for (let x=15;x<25;x++) map[idx(x,22)] = T_PATH;
  for (let x=15;x<25;x++) map[idx(x,38)] = T_PATH;
  for (let x=45;x<55;x++) map[idx(x,22)] = T_PATH;
  for (let x=45;x<55;x++) map[idx(x,38)] = T_PATH;
  for (let x=75;x<85;x++) map[idx(x,22)] = T_PATH;
  for (let x=75;x<85;x++) map[idx(x,38)] = T_PATH;

  // Water features - lakes and rivers
  // Central lake
  for (let y=20;y<28;y++){
    for (let x=35;x<45;x++){
      if (Math.hypot(x-40, y-24) < 6) map[idx(x,y)] = T_WATER;
    }
  }

  // Northern river
  for (let x=25;x<35;x++){
    for (let y=8;y<12;y++) map[idx(x,y)] = T_WATER;
  }

  // Southern river
  for (let x=60;x<70;x++){
    for (let y=48;y<52;y++) map[idx(x,y)] = T_WATER;
  }

  // Eastern lake
  for (let y=35;y<43;y++){
    for (let x=85;x<95;x++){
      if (Math.hypot(x-90, y-39) < 5) map[idx(x,y)] = T_WATER;
    }
  }

  // Sparse forest areas with scattered trees (not dense clumps)
  // Northwest forest - sparse
  const nwTrees = [[6,6],[8,8],[10,6],[12,9],[14,7],[7,11],[11,12],[15,10],[9,5],[13,8]];
  for (const [x,y] of nwTrees) if (inBounds(x,y)) map[idx(x,y)] = T_TREE;

  // Northeast forest - sparse
  const neTrees = [[84,6],[86,8],[88,6],[90,9],[92,7],[85,11],[89,12],[93,10],[87,5],[91,8]];
  for (const [x,y] of neTrees) if (inBounds(x,y)) map[idx(x,y)] = T_TREE;

  // Southwest forest - sparse
  const swTrees = [[6,48],[8,50],[10,48],[12,51],[14,49],[7,53],[11,52],[15,50],[9,47],[13,54]];
  for (const [x,y] of swTrees) if (inBounds(x,y)) map[idx(x,y)] = T_TREE;

  // Southeast forest - sparse
  const seTrees = [[84,48],[86,50],[88,48],[90,51],[92,49],[85,53],[89,52],[93,50],[87,47],[91,54]];
  for (const [x,y] of seTrees) if (inBounds(x,y)) map[idx(x,y)] = T_TREE;

  // Scattered trees across the map (well spaced)
  const scatteredTreeSpots = [
    // North area
    [25,8],[35,10],[45,7],[55,9],[65,8],[75,10],
    // Central area
    [25,25],[35,28],[45,24],[55,27],[65,25],[75,28],
    [28,35],[38,32],[48,36],[58,33],[68,35],[78,32],
    // South area
    [25,52],[35,50],[45,53],[55,51],[65,52],[75,50],
  ];
  for (const [x,y] of scatteredTreeSpots){
    if (inBounds(x,y) && map[idx(x,y)] === T_GRASS){
      map[idx(x,y)] = T_TREE;
    }
  }

  // Add bushes scattered around (not solid, just visual)
  // Some bushes are rabbit bushes (they shake!)
  const rabbitBushSpots = [
    // These bushes contain rabbits - spread across the map
    [24,15],[44,15],
    [28,30],[52,30],
    [36,45],[56,45],
    [20,20],[50,25],[80,35],
    [35,20],[65,22],
    [30,36],[70,38],
    [45,20],[75,48],
  ];
  
  const regularBushSpots = [
    // Along paths (regular)
    [12,15],[16,15],[28,15],[36,15],[52,15],[56,15],
    [12,30],[16,30],[24,30],[36,30],[44,30],[56,30],
    [12,45],[16,45],[24,45],[28,45],[44,45],[52,45],
    // Around open areas
    [20,12],[20,25],[20,35],[20,40],
    [50,12],[50,20],[50,35],[50,40],
    [80,12],[80,20],[80,25],[80,40],
    // Scattered in fields
    [25,20],[30,22],[40,22],
    [25,38],[35,38],[40,36],
    [60,20],[70,20],[75,22],
    [60,38],[65,36],[75,36],
    // Near water
    [30,18],[35,20],[40,18],
    [60,46],[65,48],[70,46],
    // More random spots
    [14,25],[18,27],[22,23],[26,28],
    [54,25],[58,27],[62,23],[66,28],
    [14,35],[18,33],[22,37],[26,32],
    [54,35],[58,33],[62,37],[66,32],
    [32,10],[38,14],[42,12],[48,10],
    [72,10],[78,14],[82,12],[88,10],
    [32,50],[38,46],[42,48],[48,50],
    [72,50],[78,46],[82,48],[88,50],
  ];
  
  for (const [x,y] of rabbitBushSpots){
    if (inBounds(x,y) && map[idx(x,y)] === T_GRASS){
      map[idx(x,y)] = T_BUSH_RABBIT;
    }
  }
  
  for (const [x,y] of regularBushSpots){
    if (inBounds(x,y) && map[idx(x,y)] === T_GRASS){
      map[idx(x,y)] = T_BUSH;
    }
  }

  // Mark solid tiles (bushes are not solid, just decorative)
  for (let y=0;y<MAP_H;y++){
    for (let x=0;x<MAP_W;x++){
      const t = map[idx(x,y)];
      if (t === T_TREE || t === T_WATER || t === T_ROCK) solid.add(idx(x,y));
    }
  }
}

function buildWorldFromManifest(){
  buildBaseMap();
  signs = [];

  // Place year signs in varied locations across the map
  // Try to place them near paths but in different areas
  const signCandidateAreas = [
    // North areas
    [10, 12], [15, 11], [25, 13], [35, 11], [45, 12], [55, 13], [65, 11], [75, 12], [85, 13],
    // Central areas
    [8, 28], [18, 27], [28, 29], [38, 27], [48, 28], [58, 29], [68, 27], [78, 28], [88, 29],
    // South areas
    [10, 46], [15, 47], [25, 45], [35, 47], [45, 46], [55, 45], [65, 47], [75, 46], [85, 45],
    // Side paths
    [20, 8], [20, 18], [20, 38], [20, 52],
    [50, 8], [50, 18], [50, 38], [50, 52],
    [80, 8], [80, 18], [80, 38], [80, 52],
  ];

  // Shuffle and pick varied locations
  const shuffled = [...signCandidateAreas].sort(() => Math.random() - 0.5);

  MANIFEST.years.forEach((yObj, i) => {
    let placed = false;
    
    // Try multiple candidate locations
    for (let j = 0; j < shuffled.length && !placed; j++) {
      const [signX, signY] = shuffled[j];
      
      // Check if location is valid (grass or path, not water/tree/rock)
      if (inBounds(signX, signY)) {
        const tile = map[idx(signX, signY)];
        if (tile === T_GRASS || tile === T_PATH) {
          map[idx(signX, signY)] = T_SIGN;
          signs.push({
            x: signX*TILE + TILE/2,
            y: signY*TILE + TILE/2,
            label: yObj.label || String(yObj.year),
            yearRef: yObj
          });
          placed = true;
          // Remove this location from future consideration
          shuffled.splice(j, 1);
        }
      }
    }
    
    // Fallback if no valid location found
    if (!placed) {
      // Find any valid grass/path tile
      for (let y = 3; y < MAP_H-3 && !placed; y++) {
        for (let x = 3; x < MAP_W-3 && !placed; x++) {
          const tile = map[idx(x, y)];
          if (tile === T_GRASS || tile === T_PATH) {
            map[idx(x, y)] = T_SIGN;
            signs.push({
              x: x*TILE + TILE/2,
              y: y*TILE + TILE/2,
              label: yObj.label || String(yObj.year),
              yearRef: yObj
            });
            placed = true;
          }
        }
      }
    }
  });

  // Goal is at the far end - a special destination
  goal = { x: 92*TILE + TILE/2, y: 30*TILE + TILE/2 };
  
  // Welcome sign near the player start
  const welcomeX = 10, welcomeY = 30;
  if (inBounds(welcomeX, welcomeY)) {
    map[idx(welcomeX, welcomeY)] = T_SIGN;
    welcomeSign = { x: welcomeX*TILE + TILE/2, y: welcomeY*TILE + TILE/2 };
  }
  
  // Pokemaster locations - spread across the map
  pokemaster = { x: 50*TILE + TILE/2, y: 22*TILE + TILE/2 };   // Central area
  pokemaster2 = { x: 75*TILE + TILE/2, y: 42*TILE + TILE/2 };  // Southeast area
  
  // Decorative rock emojis scattered around the map
  const rockPositions = [
    [15, 28], [18, 32], [22, 26], [25, 34],
    [32, 18], [38, 22], [42, 28], [48, 34],
    [55, 20], [58, 38], [62, 26], [68, 32],
    [72, 18], [78, 28], [82, 36], [86, 24],
    [12, 42], [28, 48], [45, 44], [65, 46],
    [35, 12], [55, 14], [70, 10], [85, 16],
    [20, 50], [40, 52], [60, 50], [80, 48],
  ];
  
  rockEmojis = [];
  for (const [rx, ry] of rockPositions) {
    if (inBounds(rx, ry) && map[idx(rx, ry)] === T_GRASS) {
      rockEmojis.push({
        x: rx * TILE + TILE/2,
        y: ry * TILE + TILE/2,
        emoji: "ü™®"
      });
    }
  }
}

/* =========================
   DIALOG + MODAL
   ========================= */
const dialog = document.getElementById("dialog");
const dialogTitle = document.getElementById("dialogTitle");
const dialogText = document.getElementById("dialogText");

let dialogOpen = false;
let currentInteract = null;
let visitedYears = new Set();

function showDialog(title, text){
  dialogTitle.textContent = title;
  dialogText.textContent = text;
  dialog.classList.add("show");
  dialogOpen = true;
}
function hideDialog(){
  dialog.classList.remove("show");
  dialogOpen = false;
  currentInteract = null;
}


function showYearPicker(){
  modalTitle.textContent = "üì∏ Years";
  modalSub.textContent = "Pick a year";

  const row = document.createElement("div");
  row.style.display = "flex";
  row.style.flexWrap = "wrap";
  row.style.gap = "10px";
  row.style.padding = "6px";

  MANIFEST.years.forEach(yObj=>{
    const b = document.createElement("button");
    b.className = "btn";
    b.textContent = `${yObj.year} ‚Ä¢ ${yObj.entries.length} pics`;
    b.onclick = ()=> showYearAlbum(yObj);
    row.appendChild(b);
  });

  modalBody.innerHTML = "";
  modalBody.appendChild(row);
  modal.classList.add("show");
}

function showYearAlbum(yearObj){
  modalTitle.textContent = yearObj.label || String(yearObj.year);
  modalSub.textContent = `Photos: ${yearObj.entries.length} ‚Ä¢ Click caption to edit`;

  const grid = document.createElement("div");
  grid.className = "grid";

  yearObj.entries.forEach((e, idx) => {
    const card = document.createElement("div");
    card.className = "card";
    card.onclick = (ev) => ev.stopPropagation(); // Prevent card clicks from closing modal

    const img = document.createElement("img");
    img.className = "thumb";
    img.loading = "lazy";
    img.src = e.src;
    img.title = "Click to view full image";
    img.onclick = (ev) => {
      ev.stopPropagation();
      openLightbox(e.src, e.caption);
    };

    const cap = document.createElement("div");
    cap.className = "cap";
    cap.style.cursor = "pointer";
    cap.textContent = e.caption || "Click to add caption";
    cap.title = "Click to edit caption";
    
    // Make caption editable on click
    cap.onclick = (ev) => {
      ev.stopPropagation();
      ev.preventDefault();
      isEditingCaption = true;
      
      const input = document.createElement("input");
      input.type = "text";
      input.value = e.caption || "";
      input.style.cssText = "width:100%;padding:8px;border-radius:4px;border:2px solid #4CAF50;background:#222;color:#fff;font-size:14px;";
      input.placeholder = "Enter caption...";
      
      const saveCaption = () => {
        isEditingCaption = false;
        e.caption = input.value;
        cap.textContent = input.value || "Click to add caption";
      };
      
      input.onclick = (ie) => ie.stopPropagation();
      input.onblur = saveCaption;
      input.onkeydown = (ke) => {
        ke.stopPropagation(); // Prevent escape from closing modal
        if (ke.key === "Enter") {
          saveCaption();
        }
        if (ke.key === "Escape") {
          isEditingCaption = false;
          cap.textContent = e.caption || "Click to add caption";
        }
      };
      
      cap.textContent = "";
      cap.appendChild(input);
      input.focus();
      input.select();
    };

    card.appendChild(img);
    card.appendChild(cap);
    grid.appendChild(card);
  });

  // Button container
  const btnContainer = document.createElement("div");
  btnContainer.style.cssText = "display:flex;gap:10px;margin-top:15px;flex-wrap:wrap;justify-content:center;";

  // Add copy JSON button
  const copyJsonBtn = document.createElement("button");
  copyJsonBtn.className = "btn";
  copyJsonBtn.textContent = "üìã Copy to JSON";
  copyJsonBtn.style.background = "#4CAF50";
  copyJsonBtn.onclick = (ev) => {
    ev.stopPropagation();
    const updatedEntries = yearObj.entries.map(e => ({
      src: e.src,
      date: e.date,
      caption: e.caption
    }));
    const json = JSON.stringify(updatedEntries, null, 2);
    navigator.clipboard.writeText(json).then(() => {
      copyJsonBtn.textContent = "‚úÖ Copied!";
      setTimeout(() => copyJsonBtn.textContent = "üìã Copy to JSON", 2000);
    }).catch(() => {
      // Fallback: show in prompt
      prompt("Copy this JSON:", json);
    });
  };

  btnContainer.appendChild(copyJsonBtn);

  modalBody.innerHTML = "";
  modalBody.appendChild(grid);
  modalBody.appendChild(btnContainer);
  modal.classList.add("show");
}

function hideModal(){
  modal.classList.remove("show");
  // Clear interaction when modal closes so player can move again
  currentInteract = null;
  hideDialog();
}

function escapeHtml(s){
  return (s||"").replace(/[&<>"']/g, c => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[c]));
}

// Lightbox functions
const lightbox = document.getElementById("lightbox");
const lightboxImg = document.getElementById("lightboxImg");
const lightboxCaption = document.getElementById("lightboxCaption");

function openLightbox(src, caption) {
  lightboxImg.src = src;
  lightboxCaption.textContent = caption || "";
  lightbox.classList.add("show");
}

function closeLightbox() {
  lightbox.classList.remove("show");
  lightboxImg.src = "";
}

// Close lightbox with Escape key
document.addEventListener("keydown", (e) => {
  if (e.key === "Escape" && lightbox.classList.contains("show")) {
    closeLightbox();
    e.stopPropagation();
  }
});

/* =========================
   POKEMON BATTLE SYSTEM
   ========================= */
const battleScreen = document.getElementById("battleScreen");
const battleText = document.getElementById("battleText");
const mainMenu = document.getElementById("mainMenu");
const fightMenu = document.getElementById("fightMenu");
const bagMenu = document.getElementById("bagMenu");

let inBattle = false;
let battleTurn = "player";
let isDefending = false;

// Item inventory (resets each battle)
let itemInventory = {
  'Treats': { count: 2, max: 2, heal: 15, emoji: 'üçñ' },
  'Dog Food': { count: 2, max: 2, heal: 25, emoji: 'ü¶¥' },
  'Water Bowl': { count: 2, max: 2, heal: 50, emoji: 'üíß' },
  'Super Snack': { count: 1, max: 1, heal: 75, emoji: 'ü•©' }
};

function resetInventory() {
  itemInventory['Treats'].count = 2;
  itemInventory['Dog Food'].count = 2;
  itemInventory['Water Bowl'].count = 2;
  itemInventory['Super Snack'].count = 1;
  updateBagUI();
}

function updateBagUI() {
  for (const [name, item] of Object.entries(itemInventory)) {
    const btnId = 'item' + name.replace(/\s+/g, '');
    const btn = document.getElementById(btnId);
    if (btn) {
      if (item.count <= 0) {
        btn.textContent = `${item.emoji} ${name} (empty)`;
        btn.disabled = true;
        btn.style.opacity = '0.5';
      } else {
        btn.textContent = `${item.emoji} ${name} (+${item.heal} HP) x${item.count}`;
        btn.disabled = false;
        btn.style.opacity = '1';
      }
    }
  }
}

// Battle stats
const chloe = {
  name: "Chloe",
  maxHp: 100,
  hp: 100,
  attack: 12,
  defense: 8,
  sprite: "üêï"
};

let enemy = {
  name: "Pluto",
  type: "Rabbit",
  maxHp: 50,
  hp: 50,
  attack: 8,
  defense: 5,
  sprite: "assets/images/animal images/pluto image.jpeg"
};

const enemyTypes = [
  { name: "Pluto", type: "Rabbit", maxHp: 50, attack: 8, defense: 5, sprite: "üê∞" },
  { name: "Alex", type: "Dog", maxHp: 60, attack: 10, defense: 6, sprite: "üê∂" },
];

let lastBattleTime = 0; // Start at 0 so first battle can trigger immediately
const BATTLE_COOLDOWN = 3000; // 3 seconds between battles - triggers often near bushes

// Progress tracking
let rabbitsDefeated = 0;
let trainersDefeated = 0;  // Need to defeat 2 trainers
let gameStartTime = Date.now();
let currentBattleType = "wild"; // "wild", "trainer", or "forced"
let currentTrainerRef = null; // Track which trainer we're fighting

function startRandomBattle() {
  // Bush encounters are always rabbits (Pluto)
  enemy = {
    name: "Pluto",
    type: "Rabbit",
    maxHp: 50,
    hp: 50,
    attack: 8,
    defense: 5,
    sprite: "assets/images/animal images/pluto image.jpeg"
  };
  
  currentBattleType = "wild";
  
  // Reset Chloe and inventory for this battle
  chloe.hp = chloe.maxHp;
  resetInventory();
  isDefending = false;
  battleTurn = "player";
  
  // Update UI
  document.getElementById("enemyName").textContent = enemy.name;
  document.getElementById("enemySprite").src = enemy.sprite;
  updateHpBars();
  
  // Show battle screen
  battleText.textContent = `A wild ${enemy.type} ${enemy.name} appeared!`;
  showMainMenu();
  battleScreen.classList.add("show");
  inBattle = true;
  
  // Start battle music
  startBattleMusic();
  
  // Clear movement target
  player.targetX = null;
  player.targetY = null;
}

function startPokemasterBattle(trainerRef, trainerNum) {
  // Different enemies for each Pokemaster
  if (trainerNum === 1) {
    // First Pokemaster has Bad Wolf
    enemy = {
      name: "Bad Wolf",
      type: "Evil",
      maxHp: 100,
      hp: 100,
      attack: 15,
      defense: 10,
      sprite: "üê∫",
      isEmoji: true
    };
  } else {
    // Second Pokemaster has Evil Larry the Cat
    enemy = {
      name: "Larry",
      type: "Evil Cat",
      maxHp: 120,
      hp: 120,
      attack: 18,
      defense: 12,
      sprite: "üòº",
      isEmoji: true
    };
  }
  
  currentBattleType = "trainer";
  currentTrainerRef = trainerRef;
  
  // Reset Chloe and inventory for this battle
  chloe.hp = chloe.maxHp;
  resetInventory();
  isDefending = false;
  battleTurn = "player";
  
  // Update UI
  document.getElementById("enemyName").textContent = enemy.name;
  const spriteEl = document.getElementById("enemySprite");
  if (enemy.isEmoji) {
    spriteEl.style.display = "none";
    spriteEl.insertAdjacentHTML("afterend", `<div class="pokemon-sprite enemy-emoji" id="enemyEmojiSprite">${enemy.sprite}</div>`);
  } else {
    spriteEl.src = enemy.sprite;
    spriteEl.style.display = "block";
    const emojiEl = document.getElementById("enemyEmojiSprite");
    if (emojiEl) emojiEl.remove();
  }
  updateHpBars();
  
  // Show battle screen
  battleText.textContent = `PokeMaster ${trainerNum} sent out ${enemy.type} ${enemy.name}!`;
  showMainMenu();
  battleScreen.classList.add("show");
  inBattle = true;
  
  // Start battle music
  startBattleMusic();
  
  // Clear movement target
  player.targetX = null;
  player.targetY = null;
}

function startForcedRabbitBattle() {
  // Forced rabbit battle from the goal menu
  const rabbitNum = rabbitsDefeated + 1;
  enemy = {
    name: "Pluto",
    type: "Rabbit",
    maxHp: 40 + (rabbitNum * 10), // Gets harder: 50, 60, 70 HP
    hp: 40 + (rabbitNum * 10),
    attack: 6 + (rabbitNum * 2),
    defense: 4 + rabbitNum,
    sprite: "assets/images/animal images/pluto image.jpeg"
  };
  
  currentBattleType = "forced";
  
  // Reset Chloe and inventory for this battle
  chloe.hp = chloe.maxHp;
  resetInventory();
  isDefending = false;
  battleTurn = "player";
  
  // Update UI
  document.getElementById("enemyName").textContent = enemy.name;
  document.getElementById("enemySprite").src = enemy.sprite;
  updateHpBars();

  // Show battle screen
  battleText.textContent = `Rabbit ${rabbitNum}/3: Wild ${enemy.type} ${enemy.name} appeared!`;
  showMainMenu();
  battleScreen.classList.add("show");
  inBattle = true;
  
  // Start battle music
  startBattleMusic();
  
  // Clear movement target
  player.targetX = null;
  player.targetY = null;
}

function updateHpBars() {
  // Player HP
  const playerPercent = (chloe.hp / chloe.maxHp) * 100;
  const playerBar = document.getElementById("playerHpBar");
  playerBar.style.width = playerPercent + "%";
  playerBar.classList.remove("low", "critical");
  if (playerPercent <= 20) playerBar.classList.add("critical");
  else if (playerPercent <= 50) playerBar.classList.add("low");
  document.getElementById("playerHpText").textContent = Math.max(0, chloe.hp);
  document.getElementById("playerMaxHpText").textContent = chloe.maxHp;
  
  // Enemy HP
  const enemyPercent = (enemy.hp / enemy.maxHp) * 100;
  const enemyBar = document.getElementById("enemyHpBar");
  enemyBar.style.width = enemyPercent + "%";
  enemyBar.classList.remove("low", "critical");
  if (enemyPercent <= 20) enemyBar.classList.add("critical");
  else if (enemyPercent <= 50) enemyBar.classList.add("low");
  document.getElementById("enemyHpText").textContent = Math.max(0, enemy.hp);
  document.getElementById("enemyMaxHpText").textContent = enemy.maxHp;
}

function showMainMenu() {
  mainMenu.style.display = "grid";
  fightMenu.classList.remove("show");
  bagMenu.classList.remove("show");
}

function showFightMenu() {
  mainMenu.style.display = "none";
  fightMenu.classList.add("show");
  bagMenu.classList.remove("show");
}

function showBagMenu() {
  mainMenu.style.display = "none";
  fightMenu.classList.remove("show");
  bagMenu.classList.add("show");
}

function hideAllMenus() {
  mainMenu.style.display = "none";
  fightMenu.classList.remove("show");
  bagMenu.classList.remove("show");
}

async function useMove(moveName, baseDamage) {
  if (battleTurn !== "player") return;
  hideAllMenus();
  
  // Calculate damage
  const damage = Math.floor(baseDamage + chloe.attack - enemy.defense / 2 + Math.random() * 5);
  
  battleText.textContent = `Chloe used ${moveName}!`;
  
  // Animate enemy hit
  await delay(800);
  document.getElementById("enemySprite").classList.add("hit");
  const emojiHit = document.getElementById("enemyEmojiSprite");
  if (emojiHit) emojiHit.classList.add("hit");
  enemy.hp -= damage;
  if (enemy.hp < 0) enemy.hp = 0;
  updateHpBars();
  
  await delay(400);
  document.getElementById("enemySprite").classList.remove("hit");
  const emojiHitRemove = document.getElementById("enemyEmojiSprite");
  if (emojiHitRemove) emojiHitRemove.classList.remove("hit");
  battleText.textContent = `It dealt ${damage} damage!`;
  
  await delay(1000);
  
  // Check if enemy fainted
  if (enemy.hp <= 0) {
    await victory();
    return;
  }
  
  // Enemy turn
  await enemyTurn();
}

async function useDefend() {
  if (battleTurn !== "player") return;
  hideAllMenus();
  
  isDefending = true;
  battleText.textContent = `Chloe used Chloe Power!`;
  
  await delay(800);
  battleText.textContent = `Chloe's defense rose sharply! üõ°Ô∏è‚ú®`;
  
  await delay(1000);
  
  // Enemy turn
  await enemyTurn();
}

async function useItem(itemName, healAmount) {
  if (battleTurn !== "player") return;
  
  // Check if item is available
  const item = itemInventory[itemName];
  if (!item || item.count <= 0) {
    battleText.textContent = `No ${itemName} left!`;
    return;
  }
  
  hideAllMenus();
  
  // Use the item
  item.count--;
  updateBagUI();
  
  const oldHp = chloe.hp;
  chloe.hp += healAmount;
  if (chloe.hp > chloe.maxHp) chloe.hp = chloe.maxHp;
  const actualHeal = chloe.hp - oldHp;
  
  battleText.textContent = `You used ${itemName}!`;
  
  await delay(800);
  updateHpBars();
  battleText.textContent = `Chloe recovered ${actualHeal} HP!`;
  
  await delay(1000);
  
  // Enemy turn
  await enemyTurn();
}

async function enemyTurn() {
  battleTurn = "enemy";
  
  // Enemy attacks
  const moves = [
    { name: "Nibble", damage: 8 },
    { name: "Hop Attack", damage: 12 },
    { name: "Scratch", damage: 10 },
  ];
  
  const move = moves[Math.floor(Math.random() * moves.length)];
  let damage = Math.floor(move.damage + enemy.attack - chloe.defense / 2 + Math.random() * 5);
  
  // Reduce damage if defending
  if (isDefending) {
    damage = Math.floor(damage * 0.3);
    isDefending = false;
  }
  
  battleText.textContent = `Wild ${enemy.name} used ${move.name}!`;
  
  await delay(800);
  document.getElementById("playerSprite").classList.add("hit");
  chloe.hp -= damage;
  if (chloe.hp < 0) chloe.hp = 0;
  updateHpBars();
  
  await delay(400);
  document.getElementById("playerSprite").classList.remove("hit");
  battleText.textContent = `Chloe took ${damage} damage!`;
  
  await delay(1000);
  
  // Check if Chloe fainted
  if (chloe.hp <= 0) {
    await defeat();
    return;
  }
  
  // Back to player turn
  battleTurn = "player";
  battleText.textContent = `What will Chloe do?`;
  showMainMenu();
}

async function victory() {
  if (currentBattleType === "trainer") {
    trainersDefeated++;
    battleText.textContent = `${enemy.name} fainted! You defeated PokeMaster ${trainersDefeated}/2!`;
    // Mark this trainer as defeated
    if (currentTrainerRef) {
      currentTrainerRef.defeated = true;
    }
  } else {
    battleText.textContent = `Wild ${enemy.name} fainted!`;
    // Track rabbit defeats
    if (enemy.type === "Rabbit") {
      rabbitsDefeated++;
    }
  }
  document.getElementById("enemySprite").style.opacity = "0.3";
  const emojiVictory = document.getElementById("enemyEmojiSprite");
  if (emojiVictory) emojiVictory.style.opacity = "0.3";
  
  await delay(1500);
  if (currentBattleType === "forced") {
    battleText.textContent = `Rabbit ${rabbitsDefeated}/3 defeated! üéâ`;
  } else {
    battleText.textContent = `Chloe gained experience! üéâ`;
  }
  
  await delay(2000);
  endBattle();
  
  // If in forced battle mode and more rabbits to fight
  if (currentBattleType === "forced" && rabbitsDefeated < 3) {
    await delay(500);
    startForcedRabbitBattle();
  }
}

async function defeat() {
  battleText.textContent = `Chloe fainted...`;
  document.getElementById("playerSprite").style.opacity = "0.3";
  
  await delay(1500);
  battleText.textContent = `You rushed to the Poke Center! üè•`;
  
  await delay(2000);
  chloe.hp = chloe.maxHp;
  endBattle();
}

function tryRun() {
  if (battleTurn !== "player") return;
  hideAllMenus();
  
  // 70% chance to run
  if (Math.random() < 0.7) {
    battleText.textContent = `Got away safely!`;
    setTimeout(() => endBattle(), 1000);
  } else {
    battleText.textContent = `Can't escape!`;
    setTimeout(async () => {
      await enemyTurn();
    }, 1000);
  }
}

function endBattle() {
  battleScreen.classList.remove("show");
  inBattle = false;
  lastBattleTime = Date.now(); // Reset battle cooldown timer
  
  // Stop battle music and resume overworld music
  stopBattleMusic();
  
  // Reset sprites
  document.getElementById("enemySprite").style.opacity = "1";
  document.getElementById("enemySprite").style.display = "block";
  document.getElementById("playerSprite").style.opacity = "1";
  
  // Clean up emoji sprite if it exists
  const emojiEl = document.getElementById("enemyEmojiSprite");
  if (emojiEl) emojiEl.remove();
}

function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function isNearRabbitBush() {
  // Check if player is within 1 tile radius of any rabbit bush
  const playerTileX = Math.floor(player.x / TILE);
  const playerTileY = Math.floor(player.y / TILE);
  
  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      const tx = playerTileX + dx;
      const ty = playerTileY + dy;
      if (tx >= 0 && tx < MAP_W && ty >= 0 && ty < MAP_H) {
        if (map[idx(tx, ty)] === T_BUSH_RABBIT) {
          return true;
        }
      }
    }
  }
  return false;
}

function checkForRandomEncounter() {
  if (inBattle) return;
  
  // Stop random encounters once 3 rabbits are defeated
  if (rabbitsDefeated >= 3) return;
  
  const timeSinceLastBattle = Date.now() - lastBattleTime;
  
  // Only allow battles after cooldown (1.5 minutes)
  if (timeSinceLastBattle < BATTLE_COOLDOWN) return;
  
  // Check if player is near a rabbit bush (within 1 tile) - 60% chance per check
  if (isNearRabbitBush() && Math.random() < 0.60) {
    startRandomBattle();
  }
}

/* =========================
   MOVEMENT + INTERACTION
   ========================= */
let keys = new Set();

function tileAtPx(px, py){
  const tx = Math.floor(px / TILE);
  const ty = Math.floor(py / TILE);
  if (!inBounds(tx,ty)) return { tx,ty,t:T_TREE };
  return { tx,ty,t: map[idx(tx,ty)] };
}
function isSolidPx(px, py){
  const a = tileAtPx(px,py);
  return solid.has(idx(a.tx,a.ty));
}

function tryMove(nx, ny){
  const r = 8; // Reduced collision radius
  const pts = [[nx-r, ny-r],[nx+r, ny-r],[nx-r, ny+r],[nx+r, ny+r]];
  if (pts.some(([x,y])=>isSolidPx(x,y))) return false;
  player.x = nx; player.y = ny;
  return true;
}

function nearestInteract(){
  // Check welcome sign first
  if (Math.hypot(player.x - welcomeSign.x, player.y - welcomeSign.y) < 42){
    return { type:"welcome", ref:welcomeSign };
  }
  for (const s of signs){
    const d = Math.hypot(player.x - s.x, player.y - s.y);
    if (d < 42) return { type:"sign", ref:s };
  }
  if (Math.hypot(player.x - goal.x, player.y - goal.y) < 46){
    return { type:"goal", ref:goal };
  }
  if (Math.hypot(player.x - pokemaster.x, player.y - pokemaster.y) < 50){
    return { type:"pokemaster", ref:pokemaster, num: 1 };
  }
  if (Math.hypot(player.x - pokemaster2.x, player.y - pokemaster2.y) < 50){
    return { type:"pokemaster", ref:pokemaster2, num: 2 };
  }
  return null;
}

/* =========================
   DRAW
   ========================= */
function drawTile(tx, ty, t){
  const x = tx*TILE, y = ty*TILE;

  if (t === T_GRASS){
    // Base grass with variation
    const grassShade = (tx + ty) % 3 === 0 ? "#1f6d3b" : "#1a5a32";
    ctx.fillStyle = grassShade;
    ctx.fillRect(x, y, TILE, TILE);
    
    // Grass details
    ctx.fillStyle = "rgba(139,195,74,.15)";
    ctx.fillRect(x+2, y+3, 6, 4);
    ctx.fillRect(x+12, y+8, 5, 3);
    ctx.fillRect(x+22, y+14, 4, 4);
    ctx.fillRect(x+6, y+20, 5, 3);
    ctx.fillRect(x+18, y+24, 6, 4);
    
    // Small flowers/patches
    ctx.fillStyle = "rgba(255,255,255,.08)";
    ctx.fillRect(x+8, y+12, 2, 2);
    ctx.fillRect(x+20, y+6, 2, 2);
  } else if (t === T_PATH){
    // Dirt path with texture
    ctx.fillStyle = "#8b6f47";
    ctx.fillRect(x, y, TILE, TILE);
    
    // Path texture
    ctx.fillStyle = "rgba(101,67,33,.4)";
    ctx.fillRect(x+3, y+4, 8, 6);
    ctx.fillRect(x+15, y+12, 10, 5);
    ctx.fillRect(x+6, y+20, 7, 4);
    ctx.fillRect(x+20, y+24, 6, 5);
    
    // Lighter patches
    ctx.fillStyle = "rgba(139,111,71,.3)";
    ctx.fillRect(x+10, y+8, 4, 3);
    ctx.fillRect(x+22, y+16, 3, 3);
  } else if (t === T_WATER){
    // Water with depth
    ctx.fillStyle = "#1e4a72";
    ctx.fillRect(x, y, TILE, TILE);
    
    // Water highlights
    ctx.fillStyle = "rgba(100,181,246,.4)";
    ctx.fillRect(x+2, y+3, 12, 8);
    ctx.fillRect(x+16, y+10, 10, 6);
    
    // Ripples
    ctx.fillStyle = "rgba(255,255,255,.15)";
    ctx.fillRect(x+6, y+8, 8, 2);
    ctx.fillRect(x+18, y+16, 6, 2);
    ctx.fillRect(x+4, y+22, 10, 2);
  } else if (t === T_TREE){
    // Ground under tree
    ctx.fillStyle = "#1a5a32";
    ctx.fillRect(x, y, TILE, TILE);
    
    // Tree trunk
    ctx.fillStyle = "#5d4037";
    ctx.fillRect(x+13, y+20, 6, 12);
    ctx.fillStyle = "#4e342e";
    ctx.fillRect(x+14, y+22, 4, 10);
    
    // Tree foliage - layered for depth
    ctx.fillStyle = "#2e7d32";
    ctx.beginPath();
    ctx.arc(x+16, y+12, 10, 0, Math.PI*2);
    ctx.fill();
    
    ctx.fillStyle = "#388e3c";
    ctx.beginPath();
    ctx.arc(x+14, y+10, 8, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x+18, y+10, 8, 0, Math.PI*2);
    ctx.fill();
    
    // Highlights on leaves
    ctx.fillStyle = "rgba(76,175,80,.6)";
    ctx.beginPath();
    ctx.arc(x+12, y+8, 5, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(x+20, y+8, 5, 0, Math.PI*2);
    ctx.fill();
  } else if (t === T_SIGN){
    // Grass base
    ctx.fillStyle = "#1f6d3b";
    ctx.fillRect(x, y, TILE, TILE);
    
    // Sign post (bigger)
    ctx.fillStyle = "#6b4a2d";
    ctx.fillRect(x+13, y+18, 6, 14);
    ctx.fillStyle = "#5a3d24";
    ctx.fillRect(x+14, y+20, 4, 12);
    
    // Sign board (bigger)
    ctx.fillStyle = "#f5deb3";
    ctx.fillRect(x+4, y+2, 24, 16);
    ctx.fillStyle = "#d2b48c";
    ctx.fillRect(x+6, y+4, 20, 12);
    
    // Sign border
    ctx.fillStyle = "#8b7355";
    ctx.strokeStyle = "#8b7355";
    ctx.lineWidth = 2;
    ctx.strokeRect(x+4, y+2, 24, 16);
    
    // Sign text indicator
    ctx.fillStyle = "#5a3d24";
    ctx.fillRect(x+10, y+7, 12, 2);
    ctx.fillRect(x+8, y+11, 16, 2);
  } else if (t === T_BUSH){
    // Grass base
    ctx.fillStyle = "#1f6d3b";
    ctx.fillRect(x, y, TILE, TILE);
    
    // Bush base (bigger)
    ctx.fillStyle = "#2e7d32";
    ctx.beginPath();
    ctx.ellipse(x+16, y+20, 12, 9, 0, 0, Math.PI*2);
    ctx.fill();
    
    // Bush top - multiple layers (bigger)
    ctx.fillStyle = "#388e3c";
    ctx.beginPath();
    ctx.ellipse(x+12, y+14, 9, 8, -0.2, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(x+20, y+14, 9, 8, 0.2, 0, Math.PI*2);
    ctx.fill();
    
    // Bush highlights (bigger)
    ctx.fillStyle = "#4caf50";
    ctx.beginPath();
    ctx.ellipse(x+14, y+10, 6, 6, -0.2, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(x+20, y+10, 6, 6, 0.2, 0, Math.PI*2);
    ctx.fill();
    
    // Small berries/flowers (bigger)
    ctx.fillStyle = "#ff6f00";
    ctx.fillRect(x+11, y+8, 4, 4);
    ctx.fillRect(x+19, y+9, 4, 4);
  } else if (t === T_BUSH_RABBIT){
    // Grass base
    ctx.fillStyle = "#1f6d3b";
    ctx.fillRect(x, y, TILE, TILE);
    
    // Shaking animation offset (stronger shake for bigger bush)
    const shakeTime = performance.now() / 100;
    const shakeX = Math.sin(shakeTime + tx * 10) * 3;
    const shakeY = Math.cos(shakeTime * 1.3 + ty * 10) * 2;
    
    // Bush base (shaking, bigger)
    ctx.fillStyle = "#2e7d32";
    ctx.beginPath();
    ctx.ellipse(x+16+shakeX, y+20+shakeY, 12, 9, 0, 0, Math.PI*2);
    ctx.fill();
    
    // Bush top - multiple layers (shaking, bigger)
    ctx.fillStyle = "#388e3c";
    ctx.beginPath();
    ctx.ellipse(x+12+shakeX, y+14+shakeY, 9, 8, -0.2, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(x+20+shakeX, y+14+shakeY, 9, 8, 0.2, 0, Math.PI*2);
    ctx.fill();
    
    // Bush highlights (shaking, bigger)
    ctx.fillStyle = "#4caf50";
    ctx.beginPath();
    ctx.ellipse(x+14+shakeX, y+10+shakeY, 6, 6, -0.2, 0, Math.PI*2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(x+20+shakeX, y+10+shakeY, 6, 6, 0.2, 0, Math.PI*2);
    ctx.fill();
    
    // Small berries/flowers (shaking, bigger) - different color to hint at rabbits!
    ctx.fillStyle = "#e91e63";  // Pink/red to stand out
    ctx.fillRect(x+10+shakeX, y+6+shakeY, 5, 5);
    ctx.fillRect(x+18+shakeX, y+7+shakeY, 5, 5);
    
    // Occasional sparkle effect (bigger)
    if (Math.sin(shakeTime * 2) > 0.8) {
      ctx.fillStyle = "rgba(255,255,255,0.8)";
      ctx.fillRect(x+8+shakeX, y+8+shakeY, 5, 5);
    }
  } else if (t === T_ROCK){
    // Grass base
    ctx.fillStyle = "#1f6d3b";
    ctx.fillRect(x, y, TILE, TILE);
    
    // Rock shadow
    ctx.fillStyle = "rgba(0,0,0,.2)";
    ctx.fillRect(x+4, y+20, 24, 8);
    
    // Main rock body
    ctx.fillStyle = "#616161";
    ctx.beginPath();
    ctx.ellipse(x+16, y+18, 10, 6, 0.3, 0, Math.PI*2);
    ctx.fill();
    
    // Rock highlights
    ctx.fillStyle = "#757575";
    ctx.beginPath();
    ctx.ellipse(x+14, y+16, 6, 4, 0.3, 0, Math.PI*2);
    ctx.fill();
    
    // Rock details
    ctx.fillStyle = "#424242";
    ctx.fillRect(x+12, y+20, 3, 2);
    ctx.fillRect(x+18, y+22, 2, 2);
    ctx.fillRect(x+22, y+19, 2, 3);
  }
}

function drawEntity(px, py, emoji, size = 18){
  ctx.font = `${size}px system-ui, Apple Color Emoji, Segoe UI Emoji`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(emoji, px, py);
}

function draw(){
  // Smooth camera follow
  const targetX = player.x - W/2;
  const targetY = player.y - H/2;
  cam.x += (targetX - cam.x) * 0.1;
  cam.y += (targetY - cam.y) * 0.1;
  cam.x = Math.max(0, Math.min(cam.x, MAP_W*TILE - W));
  cam.y = Math.max(0, Math.min(cam.y, MAP_H*TILE - H));

  ctx.clearRect(0,0,W,H);

  const startX = Math.floor(cam.x / TILE);
  const startY = Math.floor(cam.y / TILE);
  const endX = Math.ceil((cam.x + W)/TILE);
  const endY = Math.ceil((cam.y + H)/TILE);

  // Save context for camera transform
  ctx.save();
  ctx.translate(-cam.x, -cam.y);
  
  for (let ty=startY; ty<endY; ty++){
    for (let tx=startX; tx<endX; tx++){
      if (!inBounds(tx,ty)) continue;
      drawTile(tx,ty,map[idx(tx,ty)]);
    }
  }
  
  ctx.restore();

  // Draw entities and effects (after restore, so in screen space)
  ctx.save();
  ctx.translate(-cam.x, -cam.y);
  
  // sparkle signs not visited
  for (const s of signs){
    const key = String(s.yearRef.year);
    if (!visitedYears.has(key)){
      const sx = s.x, sy = s.y;
      ctx.globalAlpha = 0.22;
      ctx.beginPath();
      ctx.arc(sx, sy-16, 10 + 2*Math.sin(Date.now()*0.006), 0, Math.PI*2);
      ctx.fillStyle = "#ffffff";
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  // sparkle goal if all visited
  const allVisited = (MANIFEST.years?.length||0) > 0 && visitedYears.size >= MANIFEST.years.length;
  if (allVisited){
    const gx = goal.x, gy = goal.y;
    ctx.globalAlpha = 0.22;
    ctx.beginPath();
    ctx.arc(gx, gy-16, 12 + 2*Math.sin(Date.now()*0.006), 0, Math.PI*2);
    ctx.fillStyle = "#ffffff";
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // Draw decorative rock emojis
  for (const rock of rockEmojis) {
    drawEntity(rock.x, rock.y, rock.emoji, 20);
  }
  
  drawEntity(goal.x, goal.y, "üßë‚Äçüíª", 26);
  // Draw Pokemasters (show different emoji if defeated)
  drawEntity(pokemaster.x, pokemaster.y, pokemaster.defeated ? "‚ú®" : "üßô‚Äç‚ôÇÔ∏è", 28);
  drawEntity(pokemaster2.x, pokemaster2.y, pokemaster2.defeated ? "‚ú®" : "üßô", 28);
  
  // Player with walking animation (direction-aware)
  let playerEmoji = "üßç‚Äç‚ôÄÔ∏è"; // Standing
  if (player.isMoving) {
    // Alternate between walking poses based on facing direction
    if (player.facingRight) {
      const walkEmojisRight = ["üö∂‚Äç‚ôÄÔ∏è‚Äç‚û°Ô∏è", "üèÉ‚Äç‚ôÄÔ∏è‚Äç‚û°Ô∏è"];
      playerEmoji = walkEmojisRight[player.walkFrame % walkEmojisRight.length];
    } else {
      const walkEmojisLeft = ["üö∂‚Äç‚ôÄÔ∏è", "üèÉ‚Äç‚ôÄÔ∏è"];
      playerEmoji = walkEmojisLeft[player.walkFrame % walkEmojisLeft.length];
    }
  }
  drawEntity(player.x, player.y, playerEmoji, 32);
  
  ctx.restore();
}

/* =========================
   CELEBRATION SCREEN
   ========================= */
let allImages = [];
let currentSlideIndex = 0;
let slideshowInterval = null;
let noClickCount = 0;

function collectAllImages() {
  allImages = [];
  if (MANIFEST.years) {
    for (const year of MANIFEST.years) {
      if (year.entries) {
        for (const entry of year.entries) {
          allImages.push(entry.src);
        }
      }
    }
  }
  return allImages;
}

function startCelebration() {
  const celebrationScreen = document.getElementById("celebrationScreen");
  celebrationScreen.classList.add("show");
  
  // Start victory music!
  startVictoryMusic();
  
  // Collect all images for slideshow
  collectAllImages();
  
  // Start slideshow
  if (allImages.length > 0) {
    document.getElementById("slideshowImg").src = allImages[0];
    currentSlideIndex = 0;
    slideshowInterval = setInterval(() => {
      currentSlideIndex = (currentSlideIndex + 1) % allImages.length;
      document.getElementById("slideshowImg").src = allImages[currentSlideIndex];
    }, 2000);
  }
  
  // Start spawning hearts and floating images
  spawnHearts();
  spawnFloatingImages();
  
  // Reset the No button state
  noClickCount = 0;
  const yesBtn = document.getElementById("yesBtn");
  yesBtn.style.padding = "15px 40px";
  yesBtn.style.fontSize = "20px";
}

function spawnHearts() {
  const container = document.getElementById("heartsContainer");
  const hearts = ["‚ù§Ô∏è", "üíï", "üíñ", "üíó", "üíì", "üíù", "üíò", "ü©∑"];
  
  // Spawn hearts continuously
  const heartInterval = setInterval(() => {
    if (!document.getElementById("celebrationScreen").classList.contains("show")) {
      clearInterval(heartInterval);
      return;
    }
    
    const heart = document.createElement("div");
    heart.className = "floating-heart";
    heart.textContent = hearts[Math.floor(Math.random() * hearts.length)];
    heart.style.left = Math.random() * 100 + "%";
    heart.style.animationDuration = (3 + Math.random() * 2) + "s";
    heart.style.fontSize = (20 + Math.random() * 30) + "px";
    container.appendChild(heart);
    
    // Remove heart after animation
    setTimeout(() => heart.remove(), 5000);
  }, 200);
}

function spawnFloatingImages() {
  const container = document.getElementById("heartsContainer");
  
  // Spawn floating images continuously
  const imageInterval = setInterval(() => {
    if (!document.getElementById("celebrationScreen").classList.contains("show")) {
      clearInterval(imageInterval);
      return;
    }
    
    if (allImages.length === 0) return;
    
    const floatImg = document.createElement("img");
    floatImg.className = "floating-image";
    floatImg.src = allImages[Math.floor(Math.random() * allImages.length)];
    floatImg.style.left = (5 + Math.random() * 85) + "%";
    floatImg.style.top = (55 + Math.random() * 35) + "%"; // Bottom half only, avoid slideshow
    floatImg.style.animationDuration = (6 + Math.random() * 4) + "s";
    floatImg.style.animationDelay = Math.random() * 0.5 + "s";
    floatImg.style.width = (60 + Math.random() * 40) + "px";
    floatImg.style.height = (45 + Math.random() * 30) + "px";
    container.appendChild(floatImg);
    
    // Remove image after animation
    setTimeout(() => floatImg.remove(), 12000);
  }, 1500);
}

function handleYes() {
  // Stop slideshow
  if (slideshowInterval) clearInterval(slideshowInterval);
  
  // Hide celebration screen
  document.getElementById("celebrationScreen").classList.remove("show");
  
  // Show final celebration with confetti
  const finalCelebration = document.getElementById("finalCelebration");
  finalCelebration.classList.add("show");
  
  // Spawn confetti
  spawnConfetti();
  
  // Play celebration sound or just keep the music going
}

function handleNo() {
  noClickCount++;
  const yesBtn = document.getElementById("yesBtn");
  const noBtn = document.getElementById("noBtn");
  
  // Make YES button bigger each time
  const baseSize = 20;
  const basePadding = 15;
  const growth = noClickCount * 8;
  const paddingGrowth = noClickCount * 10;
  
  yesBtn.style.fontSize = (baseSize + growth) + "px";
  yesBtn.style.padding = (basePadding + paddingGrowth) + "px " + (40 + paddingGrowth * 2) + "px";
  
  // Add more sad faces to no button
  const sadFaces = "üò¢".repeat(Math.min(noClickCount, 5));
  noBtn.textContent = `${sadFaces} No :( ${sadFaces}`;
  
  // If clicked too many times, YES button takes over
  if (noClickCount >= 5) {
    yesBtn.style.position = "fixed";
    yesBtn.style.top = "50%";
    yesBtn.style.left = "50%";
    yesBtn.style.transform = "translate(-50%, -50%)";
    yesBtn.style.zIndex = "9999";
    yesBtn.style.fontSize = "60px";
    yesBtn.style.padding = "50px 100px";
    noBtn.style.display = "none";
  }
  
  if (noClickCount >= 8) {
    yesBtn.style.width = "100vw";
    yesBtn.style.height = "100vh";
    yesBtn.style.fontSize = "100px";
    yesBtn.style.borderRadius = "0";
  }
}

function spawnConfetti() {
  const container = document.getElementById("finalCelebration");
  const colors = ["#ff0000", "#00ff00", "#0000ff", "#ffff00", "#ff00ff", "#00ffff", "#ff69b4", "#ffd700"];
  
  // Spawn lots of confetti
  for (let i = 0; i < 150; i++) {
    setTimeout(() => {
      const confetti = document.createElement("div");
      confetti.className = "confetti";
      confetti.style.left = Math.random() * 100 + "%";
      confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
      confetti.style.animationDuration = (2 + Math.random() * 2) + "s";
      confetti.style.animationDelay = Math.random() * 0.5 + "s";
      confetti.style.width = (5 + Math.random() * 10) + "px";
      confetti.style.height = (5 + Math.random() * 10) + "px";
      confetti.style.borderRadius = Math.random() > 0.5 ? "50%" : "0";
      container.appendChild(confetti);
      
      // Remove confetti after animation
      setTimeout(() => confetti.remove(), 5000);
    }, i * 20);
  }
  
  // Keep spawning confetti
  setInterval(() => {
    for (let i = 0; i < 20; i++) {
      const confetti = document.createElement("div");
      confetti.className = "confetti";
      confetti.style.left = Math.random() * 100 + "%";
      confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
      confetti.style.animationDuration = (2 + Math.random() * 2) + "s";
      confetti.style.width = (5 + Math.random() * 10) + "px";
      confetti.style.height = (5 + Math.random() * 10) + "px";
      container.appendChild(confetti);
      setTimeout(() => confetti.remove(), 5000);
    }
  }, 1000);
}

function playAgain() {
  // Hide all celebration screens
  document.getElementById("finalCelebration").classList.remove("show");
  document.getElementById("celebrationScreen").classList.remove("show");
  
  // Stop victory music and restart overworld music
  stopVictoryMusic();
  if (audio && !muted) {
    audio.currentTime = 0;
    audio.play().catch(() => {});
  }
  
  // Reset game state
  visitedYears.clear();
  rabbitsDefeated = 0;
  trainersDefeated = 0;
  pokemaster.defeated = false;
  pokemaster2.defeated = false;
  gameStartTime = Date.now();
  noClickCount = 0;
  
  // Reset Yes button styles
  const yesBtn = document.getElementById("yesBtn");
  yesBtn.style.position = "";
  yesBtn.style.top = "";
  yesBtn.style.left = "";
  yesBtn.style.transform = "";
  yesBtn.style.zIndex = "";
  yesBtn.style.width = "";
  yesBtn.style.height = "";
  yesBtn.style.borderRadius = "";
  yesBtn.style.fontSize = "20px";
  yesBtn.style.padding = "15px 40px";
  
  // Reset No button
  const noBtn = document.getElementById("noBtn");
  noBtn.style.display = "";
  noBtn.textContent = "üò¢ No :(";
  
  // Reset player position
  player.x = 8*TILE + TILE/2;
  player.y = 30*TILE + TILE/2;
  player.targetX = null;
  player.targetY = null;
  
  // Stop slideshow if running
  if (slideshowInterval) {
    clearInterval(slideshowInterval);
    slideshowInterval = null;
  }
  
  // Clear hearts container
  document.getElementById("heartsContainer").innerHTML = "";
}

let last = performance.now();
let lastEncounterCheck = 0;

function loop(now){
  const dt = Math.min(0.033, (now-last)/1000);
  last = now;

  // Only block movement when modal (photo viewer) or battle is active
  // Dialog (hint box) should NOT block movement
  if (!modal.classList.contains("show") && !inBattle){
    
    // Check for encounters every 500ms even when standing still
    if (now - lastEncounterCheck > 500) {
      lastEncounterCheck = now;
      checkForRandomEncounter();
    }
    // Click-to-move: move towards target if set
    if (player.targetX !== null && player.targetY !== null){
      const dx = player.targetX - player.x;
      const dy = player.targetY - player.y;
      const dist = Math.hypot(dx, dy);
      
      if (dist < 5){
        // Reached target
        player.targetX = null;
        player.targetY = null;
        player.isMoving = false;
      } else {
        // Move towards target
        player.isMoving = true;
        
        // Update facing direction based on horizontal movement
        if (dx > 5) player.facingRight = true;
        else if (dx < -5) player.facingRight = false;
        
        // Update walk frame every 150ms
        if (now - player.lastWalkTime > 150) {
          player.walkFrame = (player.walkFrame + 1) % 2;
          player.lastWalkTime = now;
        }
        
        const vx = dx / dist;
        const vy = dy / dist;
        const nx = player.x + vx * player.speed * dt;
        const ny = player.y + vy * player.speed * dt;
        
        // Check if we would overshoot the target
        const newDx = player.targetX - nx;
        const newDy = player.targetY - ny;
        const newDist = Math.hypot(newDx, newDy);
        
        if (newDist > dist){
          // Overshot, snap to target
          player.x = player.targetX;
          player.y = player.targetY;
          player.targetX = null;
          player.targetY = null;
          player.isMoving = false;
        } else {
          // Try to move
          const moved = tryMove(nx, ny);
          if (!moved){
            // Try moving in X and Y separately if diagonal movement fails
            const movedX = tryMove(nx, player.y);
            const movedY = tryMove(player.x, ny);
            if (movedX || movedY) {
              // Check if player is near a rabbit bush (within 1 tile radius)
              checkForRandomEncounter();
            }
          } else {
            // Check if player is near a rabbit bush (within 1 tile radius)
            checkForRandomEncounter();
          }
        }
      }
    } else {
      player.isMoving = false;
    }

    // Check for nearby interactable objects
    const near = nearestInteract();
    if (near){
      currentInteract = near;
      if (near.type === "welcome"){
        showDialog("üíå Welcome!", `Hi my love, welcome to your very own Pokemon adventure! (Anniversary Edition)\n\nGo around, look for sign boards that have our pictures, fight different animals and PokeMasters, and in the end go see me! üíï`);
      } else if (near.type === "sign"){
        const interactHint = isMobile ? "Tap the button below" : "Press E";
        showDialog("Sign", `${near.ref.label}\n${interactHint} to open this year.`);
      } else if (near.type === "pokemaster") {
        const trainerNum = near.num;
        const trainerEmoji = trainerNum === 1 ? "üßô‚Äç‚ôÇÔ∏è" : "üßô";
        const interactHint = isMobile ? "Tap the button below" : "Press E";
        if (near.ref.defeated) {
          showDialog(`${trainerEmoji} PokeMaster ${trainerNum}`, `You've already defeated me!\nWell done, trainer! ‚ú®`);
        } else {
          showDialog(`${trainerEmoji} PokeMaster ${trainerNum}`, `Welcome, trainer!\nI see you have Chloe with you.\n${interactHint} to battle me!`);
        }
      } else {
        // Goal - check all requirements
        const allVisited = visitedYears.size >= (MANIFEST.years?.length || 0);
        const allRabbits = rabbitsDefeated >= 3;
        const timePassed = (Date.now() - gameStartTime) > 300000; // 5 minutes
        
        let message = "";
        if (!allVisited) {
          message = `Visit all years first (${visitedYears.size}/${MANIFEST.years.length}).`;
        } else if (trainersDefeated < 2) {
          message = `Defeat both PokeMasters! (${trainersDefeated}/2)\nFind the üßô‚Äç‚ôÇÔ∏è and üßô on the map.`;
        } else if (!allRabbits) {
          message = `Defeat 3 rabbits! (${rabbitsDefeated}/3)\nüåø Hint: Look for shaking bushes!`;
          if (timePassed) {
            message += `\n\nPress E to fight the rabbits now!`;
          }
        } else {
          const interactHint = isMobile ? "Tap the button below" : "Press E";
          message = `You made it!\n${interactHint}.`;
        }
        
        showDialog(MANIFEST.partnerName || "Partner", message);
      }
    } else if (dialogOpen) hideDialog();
    
    // Update mobile interact button
    updateMobileInteractButton();
  }

  draw();
  requestAnimationFrame(loop);
}

/* =========================
   INPUT
   ========================= */
window.addEventListener("keydown", (e)=>{
  const k = e.key.length===1 ? e.key.toLowerCase() : e.key;
  
  if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","w","a","s","d","e","r","Escape"].includes(k)) {
    e.preventDefault();
    keys.add(k);
  }

  if (k === "Escape" && !isEditingCaption){ hideDialog(); hideModal(); }

  if (k === "r"){
    // Close dialog if open
    if (dialogOpen) {
      hideDialog();
      return;
    }
    // Otherwise restart the game
    visitedYears.clear();
    hideModal();
  }

  if (k === "e"){
    if (modal.classList.contains("show")) return;

    if (currentInteract?.type === "sign"){
      const yObj = currentInteract.ref.yearRef;
      visitedYears.add(String(yObj.year));
      hideDialog(); // Hide dialog first
      currentInteract = null; // Clear interaction
      showYearAlbum(yObj);
    } else if (currentInteract?.type === "pokemaster"){
      // Save references BEFORE hideDialog (which clears currentInteract)
      const trainerRef = currentInteract.ref;
      const trainerNum = currentInteract.num;
      hideDialog();
      if (!trainerRef.defeated) {
        startPokemasterBattle(trainerRef, trainerNum);
      }
    } else if (currentInteract?.type === "goal"){
      const allVisited = visitedYears.size >= (MANIFEST.years?.length || 0);
      const allRabbits = rabbitsDefeated >= 3;
      const timePassed = (Date.now() - gameStartTime) > 300000; // 5 minutes
      
      hideDialog();
      
      // Check years first
      if (!allVisited){
        showDialog("Not yet‚Ä¶", `Visit all years first.\n(${visitedYears.size}/${MANIFEST.years.length})`);
        return;
      }
      
      // Check trainers
      if (trainersDefeated < 2){
        showDialog("Not yet‚Ä¶", `Defeat both PokeMasters! (${trainersDefeated}/2)\nFind the üßô‚Äç‚ôÇÔ∏è and üßô on the map.`);
        return;
      }
      
      // Check rabbits
      if (!allRabbits){
        if (timePassed) {
          // Offer to fight rabbits now
          showDialog("üê∞ Rabbit Challenge", `You need to defeat ${3 - rabbitsDefeated} more rabbit(s)!\n\nPress E to fight them now!`);
          
          const rabbitHandler = (ev)=>{
            const kk = ev.key.length===1 ? ev.key.toLowerCase() : ev.key;
            if (kk !== "e") return;
            window.removeEventListener("keydown", rabbitHandler);
            hideDialog();
            startForcedRabbitBattle();
          };
          window.addEventListener("keydown", rabbitHandler);
        } else {
          const timeLeft = Math.ceil((300000 - (Date.now() - gameStartTime)) / 60000);
          showDialog("Not yet‚Ä¶", `Defeat 3 rabbits! (${rabbitsDefeated}/3)\nüåø Hint: Look for shaking bushes!\n\n(Option to fight here in ~${timeLeft} min)`);
        }
        return;
      }
      
      // All requirements met! Show the celebration screen!
      hideDialog();
      startCelebration();
    }
  }
});

window.addEventListener("keyup", (e)=>{
  const k = e.key.length===1 ? e.key.toLowerCase() : e.key;
  keys.delete(k);
});

// Click-to-move
canvas.addEventListener("click", (e)=>{
  // If modal is open, close it when clicking canvas
  if (modal.classList.contains("show")) {
    hideModal();
    return;
  }
  
  // If dialog is open, close it when clicking
  if (dialogOpen) {
    hideDialog();
    // Still allow the click to set movement target
  }
  
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  
  const clickX = (e.clientX - rect.left) * scaleX;
  const clickY = (e.clientY - rect.top) * scaleY;
  
  // Convert screen coordinates to world coordinates
  const worldX = clickX + cam.x;
  const worldY = clickY + cam.y;
  
  // Set target position
  player.targetX = worldX;
  player.targetY = worldY;
});

// Touch support for mobile
canvas.addEventListener("touchstart", (e) => {
  e.preventDefault();
  
  if (modal.classList.contains("show") || inBattle) return;
  
  if (dialogOpen) {
    hideDialog();
  }
  
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const scaleX = canvas.width / rect.width;
  const scaleY = canvas.height / rect.height;
  
  const touchX = (touch.clientX - rect.left) * scaleX;
  const touchY = (touch.clientY - rect.top) * scaleY;
  
  const worldX = touchX + cam.x;
  const worldY = touchY + cam.y;
  
  player.targetX = worldX;
  player.targetY = worldY;
}, { passive: false });

/* =========================
   MOBILE SUPPORT
   ========================= */
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;

const mobileInteractBtn = document.getElementById("mobileInteractBtn");
const mobileControls = document.getElementById("mobileControls");

// Show/hide mobile tip
if (isMobile) {
  const tipDesktop = document.querySelector(".tip");
  const tipMobile = document.querySelector(".tip-mobile");
  if (tipDesktop) tipDesktop.style.display = "none";
  if (tipMobile) tipMobile.style.display = "block";
}

// Mobile interact button handler
mobileInteractBtn.addEventListener("click", (e) => {
  e.stopPropagation();
  
  if (currentInteract?.type === "sign") {
    const yObj = currentInteract.ref.yearRef;
    visitedYears.add(String(yObj.year));
    hideDialog();
    currentInteract = null;
    showYearAlbum(yObj);
  } else if (currentInteract?.type === "pokemaster") {
    const trainerRef = currentInteract.ref;
    const trainerNum = currentInteract.num;
    hideDialog();
    if (!trainerRef.defeated) {
      startPokemasterBattle(trainerRef, trainerNum);
    }
  } else if (currentInteract?.type === "goal") {
    const allVisited = visitedYears.size >= (MANIFEST.years?.length || 0);
    const allRabbits = rabbitsDefeated >= 3;
    const timePassed = (Date.now() - gameStartTime) > 300000;
    
    hideDialog();
    
    if (!allVisited) {
      showDialog("Not yet‚Ä¶", `Visit all years first.\n(${visitedYears.size}/${MANIFEST.years.length})`);
      return;
    }
    
    if (trainersDefeated < 2) {
      showDialog("Not yet‚Ä¶", `Defeat both PokeMasters! (${trainersDefeated}/2)\nFind the üßô‚Äç‚ôÇÔ∏è and üßô on the map.`);
      return;
    }
    
    if (!allRabbits) {
      if (timePassed) {
        startForcedRabbitBattle();
      } else {
        const timeLeft = Math.ceil((300000 - (Date.now() - gameStartTime)) / 60000);
        showDialog("Not yet‚Ä¶", `Defeat 3 rabbits! (${rabbitsDefeated}/3)\nüåø Hint: Look for shaking bushes!\n\n(Option to fight here in ~${timeLeft} min)`);
      }
      return;
    }
    
    hideDialog();
    startCelebration();
  }
});

// Update mobile interact button visibility based on nearby objects
function updateMobileInteractButton() {
  if (!isMobile) return;
  
  // Hide during battles, modals, and celebration
  if (inBattle || modal.classList.contains("show") || 
      document.getElementById("celebrationScreen").classList.contains("show") ||
      document.getElementById("finalCelebration").classList.contains("show")) {
    mobileInteractBtn.classList.remove("show");
    return;
  }
  
  const near = nearestInteract();
  if (near && near.type !== "welcome") {
    mobileInteractBtn.classList.add("show");
    
    // Update button text based on interaction type
    if (near.type === "sign") {
      mobileInteractBtn.textContent = "üì∏ Open Album";
    } else if (near.type === "pokemaster") {
      if (near.ref.defeated) {
        mobileInteractBtn.textContent = "‚ú® Defeated";
      } else {
        mobileInteractBtn.textContent = "‚öîÔ∏è Battle!";
      }
    } else if (near.type === "goal") {
      mobileInteractBtn.textContent = "üíï Interact";
    }
  } else {
    mobileInteractBtn.classList.remove("show");
  }
}

/* =========================
   START
   ========================= */
(async function init(){
  try{
    await loadManifest();
    setupMusic();
    
    // Ensure window has focus for keyboard events
    window.focus();
    canvas.focus();
    
    requestAnimationFrame(loop);
  } catch (err){
    console.error(err);
    leftBadge.textContent = "‚ö†Ô∏è Couldn't load manifest file";

    alert(
      "Could not load manifest.\n\n" +
      "Run with a local server (not file://).\n\n" +
      "In this folder, run:\n" +
      "  python -m http.server 8000\n\n" +
      "Then open:\n" +
      "  http://localhost:8000\n"
    );
  }
})();
</script>
</body>
</html>
